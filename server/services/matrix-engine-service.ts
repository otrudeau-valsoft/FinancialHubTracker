/**
 * Matrix Engine Service
 * 
 * This service evaluates portfolio stocks against matrix rules to generate
 * alerts and recommendations for position changes and rating adjustments.
 */

import { db } from '../db';
import { alerts, currentPrices, historicalPrices, rsiData, macdData, movingAverageData, portfolioUSD, portfolioCAD, portfolioINTL } from '../../shared/schema';
import { eq, and, or, desc, asc, gt, lt, between, sql, inArray } from 'drizzle-orm';
import { MATRIX_THRESHOLDS } from '../routes/matrix-thresholds';
import yahooFinance from 'yahoo-finance2';

// Portfolio regions
const REGIONS = ['USD', 'CAD', 'INTL'] as const;
type Region = typeof REGIONS[number];

// Stock classifications
const STOCK_TYPES = ['Compounder', 'Catalyst', 'Cyclical'] as const;
type StockType = typeof STOCK_TYPES[number]; 

// Rating values
const RATINGS = ['1', '2', '3', '4'] as const;
type Rating = typeof RATINGS[number];

// Matrix rule types by action
type ActionType = 'Increase' | 'Decrease' | 'Rating';

// Matrix rule data source types
type DataSource = 'historical_prices' | 'rsi_data' | 'macd_data' | 'moving_average_data' | 'market_indices' | 'portfolio' | 'earnings';

// Matrix rule to evaluate
interface MatrixRule {
  id: number;
  ruleId: string;
  ruleName: string;
  description: string;
  actionType: ActionType;
  ratingAction?: 'Increase' | 'Decrease';
  thresholds: {
    [key in StockType]: {
      [key in Rating]: string;
    }
  };
  evaluationMethod: 'percent' | 'value' | 'boolean' | 'delta';
  evaluationLogic: 'below' | 'above' | 'at' | 'positive' | 'negative';
  dataSource: DataSource;
  orderNumber: number;
}

// Stock data with relevant metrics for rule evaluation
interface StockData {
  symbol: string;
  company: string;
  region: string;
  stockType: string;
  rating: string;
  quantity: number;
  currentPrice?: number;
  fiftyTwoWeekHigh?: number;
  fiftyTwoWeekLow?: number;
  rsi14?: number;
  macdHistogram?: number;
  macdSignal?: number;
  macdLine?: number;
  priceChange90d?: number;
  percentOfPortfolio?: number;
  ma50?: number;
  ma200?: number;
}

// Alert generated by rule evaluation
interface Alert {
  symbol: string;
  message: string;
  details: string;
  severity: 'critical' | 'warning' | 'info';
  ruleType: string;
  region: string;
}

/**
 * Get the appropriate portfolio table based on region
 */
function getPortfolioTable(region: Region) {
  switch(region) {
    case 'USD': return portfolioUSD;
    case 'CAD': return portfolioCAD;
    case 'INTL': return portfolioINTL;
    default: throw new Error(`Invalid region: ${region}`);
  }
}

/**
 * Convert normalized stock type to internal format
 */
function normalizeStockType(stockType: string): StockType {
  // Map database stock types to matrix rule format
  if (stockType === 'Comp') return 'Compounder';
  if (stockType === 'Cat') return 'Catalyst';
  if (stockType === 'Cycl') return 'Cyclical';
  
  // If it's already in the right format
  if (STOCK_TYPES.includes(stockType as StockType)) {
    return stockType as StockType;
  }
  
  // Default to Compounder if unknown
  console.warn(`Unknown stock type: ${stockType}, defaulting to Compounder`);
  return 'Compounder';
}

/**
 * Parse a threshold value to numeric format
 */
function parseThreshold(threshold: string): number | null {
  if (threshold === 'N/A') return null;
  
  // Handle percentage values
  if (threshold.includes('%')) {
    return parseFloat(threshold.replace('%', '')) / 100;
  }
  
  // Handle minus in front of numbers
  if (threshold.includes('- ')) {
    return -parseFloat(threshold.replace('- ', ''));
  }
  
  // Handle +/- values (range values)
  if (threshold.includes('+/- ')) {
    return parseFloat(threshold.replace('+/- ', '')) / 100;
  }
  
  // Normal numeric values
  return parseFloat(threshold);
}

/**
 * Get real-time stock data for a specific region
 */
async function getStockData(region: Region): Promise<StockData[]> {
  try {
    const portfolioTable = getPortfolioTable(region);
    
    // Get all stocks for the region
    const portfolioStocks = await db.select()
      .from(portfolioTable)
      .orderBy(portfolioTable.symbol);
    
    if (!portfolioStocks.length) {
      console.log(`No stocks found for region: ${region}`);
      return [];
    }
    
    // Extract symbols
    const symbols = portfolioStocks.map(stock => stock.symbol);
    
    // Get current prices
    const currentPriceData = await db.select()
      .from(currentPrices)
      .where(and(
        eq(currentPrices.region, region),
        inArray(currentPrices.symbol, symbols)
      ));
    
    // Create a map of current prices for easy lookup
    const priceMap = new Map<string, any>();
    currentPriceData.forEach(price => {
      priceMap.set(price.symbol, price);
    });
    
    // Get latest RSI values
    const rsiValues = await db.select({
      symbol: rsiData.symbol,
      rsi14: rsiData.rsi14
    })
    .from(rsiData)
    .where(and(
      eq(rsiData.region, region),
      inArray(rsiData.symbol, symbols)
    ))
    .orderBy(desc(rsiData.date))
    .limit(symbols.length);
    
    // Create a map of RSI values
    const rsiMap = new Map<string, number>();
    rsiValues.forEach(rsi => {
      if (rsi.rsi14) {
        rsiMap.set(rsi.symbol, parseFloat(rsi.rsi14.toString()));
      }
    });
    
    // Get latest MACD values
    const macdValues = await db.select({
      symbol: macdData.symbol,
      macd: macdData.macd,
      signal: macdData.signal,
      histogram: macdData.histogram
    })
    .from(macdData)
    .where(and(
      eq(macdData.region, region),
      inArray(macdData.symbol, symbols)
    ))
    .orderBy(desc(macdData.date))
    .limit(symbols.length);
    
    // Create a map of MACD values
    const macdMap = new Map<string, any>();
    macdValues.forEach(macd => {
      macdMap.set(macd.symbol, macd);
    });
    
    // Get latest Moving Average values
    const movingAverageValues = await db.select({
      symbol: movingAverageData.symbol,
      ma50: movingAverageData.ma50,
      ma200: movingAverageData.ma200
    })
    .from(movingAverageData)
    .where(and(
      eq(movingAverageData.region, region),
      inArray(movingAverageData.symbol, symbols)
    ))
    .orderBy(desc(movingAverageData.date))
    .limit(symbols.length);
    
    // Create a map of Moving Average values
    const movingAverageMap = new Map<string, any>();
    movingAverageValues.forEach(ma => {
      movingAverageMap.set(ma.symbol, ma);
    });
    
    // Get historical prices for calculating moving averages and price changes
    const ninetyDaysAgo = new Date();
    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
    
    const historicalPriceData = await db.select()
      .from(historicalPrices)
      .where(and(
        eq(historicalPrices.region, region),
        inArray(historicalPrices.symbol, symbols),
        gt(historicalPrices.date, ninetyDaysAgo.toISOString().split('T')[0])
      ))
      .orderBy(asc(historicalPrices.symbol), desc(historicalPrices.date));
    
    // Group historical prices by symbol
    const historicalPricesBySymbol = new Map<string, any[]>();
    historicalPriceData.forEach(price => {
      if (!historicalPricesBySymbol.has(price.symbol)) {
        historicalPricesBySymbol.set(price.symbol, []);
      }
      historicalPricesBySymbol.get(price.symbol)!.push(price);
    });
    
    // Calculate 90-day price changes and initialize moving averages maps
    const priceChangeMap = new Map<string, number>();
    const ma50Map = new Map<string, number>();
    const ma200Map = new Map<string, number>();
    
    symbols.forEach(symbol => {
      const prices = historicalPricesBySymbol.get(symbol) || [];
      
      if (prices.length > 0) {
        // Calculate 90-day price change
        const latestPrice = parseFloat(prices[0].close.toString());
        const oldestPrice = parseFloat(prices[prices.length - 1].close.toString());
        
        if (latestPrice && oldestPrice) {
          const priceChange90d = (latestPrice - oldestPrice) / oldestPrice;
          priceChangeMap.set(symbol, priceChange90d);
        }
        
        // Use the dedicated Moving Average data if available
        const movingAverageData = movingAverageMap.get(symbol);
        if (movingAverageData) {
          // Use MA50 from dedicated moving average data
          if (movingAverageData.ma50) {
            ma50Map.set(symbol, parseFloat(movingAverageData.ma50.toString()));
          }
          
          // Use MA200 from dedicated moving average data
          if (movingAverageData.ma200) {
            ma200Map.set(symbol, parseFloat(movingAverageData.ma200.toString()));
          }
        } else {
          // Fallback to calculating from historical prices if no dedicated MA data
          // Calculate 50-day moving average (if we have enough data)
          if (prices.length >= 50) {
            const last50Prices = prices.slice(0, 50);
            const sum50 = last50Prices.reduce((acc, price) => acc + parseFloat(price.close.toString()), 0);
            ma50Map.set(symbol, sum50 / 50);
          }
          
          // Calculate 200-day moving average (if we have enough data)
          if (prices.length >= 200) {
            const last200Prices = prices.slice(0, 200);
            const sum200 = last200Prices.reduce((acc, price) => acc + parseFloat(price.close.toString()), 0);
            ma200Map.set(symbol, sum200 / 200);
          }
        }
      }
    });
    
    // Calculate the total portfolio value to determine percentages
    let totalPortfolioValue = 0;
    portfolioStocks.forEach(stock => {
      const currentPrice = priceMap.get(stock.symbol)?.regularMarketPrice || 0;
      const quantity = parseFloat(stock.quantity.toString());
      totalPortfolioValue += currentPrice * quantity;
    });
    
    // Combine all data into StockData objects
    const stockDataList: StockData[] = portfolioStocks.map(stock => {
      const symbol = stock.symbol;
      const currentPriceInfo = priceMap.get(symbol);
      const quantity = parseFloat(stock.quantity.toString());
      const currentPrice = currentPriceInfo?.regularMarketPrice ? parseFloat(currentPriceInfo.regularMarketPrice.toString()) : undefined;
      
      // Calculate percentage of portfolio
      const percentOfPortfolio = currentPrice && totalPortfolioValue > 0 
        ? (currentPrice * quantity) / totalPortfolioValue
        : undefined;
      
      return {
        symbol,
        company: stock.company,
        region,
        stockType: stock.stockType,
        rating: stock.rating,
        quantity,
        currentPrice,
        fiftyTwoWeekHigh: currentPriceInfo?.fiftyTwoWeekHigh ? parseFloat(currentPriceInfo.fiftyTwoWeekHigh.toString()) : undefined,
        fiftyTwoWeekLow: currentPriceInfo?.fiftyTwoWeekLow ? parseFloat(currentPriceInfo.fiftyTwoWeekLow.toString()) : undefined,
        rsi14: rsiMap.get(symbol),
        macdHistogram: macdMap.get(symbol)?.histogram ? parseFloat(macdMap.get(symbol).histogram.toString()) : undefined,
        macdSignal: macdMap.get(symbol)?.signal ? parseFloat(macdMap.get(symbol).signal.toString()) : undefined,
        macdLine: macdMap.get(symbol)?.macd ? parseFloat(macdMap.get(symbol).macd.toString()) : undefined,
        priceChange90d: priceChangeMap.get(symbol),
        percentOfPortfolio,
        ma50: ma50Map.get(symbol),
        ma200: ma200Map.get(symbol)
      };
    });
    
    return stockDataList;
  } catch (error) {
    console.error(`Error fetching stock data for region ${region}:`, error);
    return [];
  }
}

/**
 * Evaluate a specific rule for a given stock
 */
function evaluateRule(rule: MatrixRule, stock: StockData): boolean {
  // Skip if stockType is missing or not recognized
  if (!stock.stockType) return false;
  
  // Normalize stock type to match matrix threshold format
  const normalizedStockType = normalizeStockType(stock.stockType);
  
  // Get the threshold for this stock type and rating
  const thresholdValue = rule.thresholds[normalizedStockType]?.[stock.rating as Rating];
  
  // Skip if threshold is N/A or undefined for this stock type/rating combination
  if (!thresholdValue || thresholdValue === 'N/A') return false;
  
  // Parse the threshold value to a number (if possible)
  const threshold = parseThreshold(thresholdValue);
  
  // Skip if threshold couldn't be parsed
  if (threshold === null) return false;
  
  // Based on the rule's data source, evaluate using the appropriate data
  switch (rule.dataSource) {
    case 'historical_prices': {
      // Rules using historical price data
      switch (rule.ruleId) {
        case 'price-52wk': {
          // Price vs 52-week high rule
          if (!stock.currentPrice || !stock.fiftyTwoWeekHigh) return false;
          
          // Calculate how far below 52-week high
          const priceDiff = (stock.fiftyTwoWeekHigh - stock.currentPrice) / stock.fiftyTwoWeekHigh;
          
          // For "below" logic, trigger if price is below threshold percentage
          return rule.evaluationLogic === 'below' && priceDiff >= threshold;
        }
        
        case 'price-90day': {
          // 90-day price increase rule
          if (!stock.priceChange90d) return false;
          
          // For "above" logic, trigger if price change is above threshold
          return rule.evaluationLogic === 'above' && stock.priceChange90d >= threshold;
        }
        
        case 'golden-cross-pos': {
          // Golden cross (positive) - 50-day MA crosses above 200-day MA
          if (!stock.ma50 || !stock.ma200) return false;
          
          // For "positive" logic, trigger if 50-day MA is above 200-day MA
          return rule.evaluationLogic === 'positive' && stock.ma50 > stock.ma200;
        }
        
        case 'golden-cross-neg': {
          // Death cross (negative) - 50-day MA crosses below 200-day MA
          if (!stock.ma50 || !stock.ma200) return false;
          
          // For "negative" logic, trigger if 50-day MA is below 200-day MA
          return rule.evaluationLogic === 'negative' && stock.ma50 < stock.ma200;
        }
        
        case 'at-200ma': {
          // Price is near 200-day moving average
          if (!stock.currentPrice || !stock.ma200) return false;
          
          // Calculate how close price is to 200-day MA (as percentage)
          const priceDiff = Math.abs(stock.currentPrice - stock.ma200) / stock.ma200;
          
          // For "at" logic, trigger if price is within threshold percentage of MA
          return rule.evaluationLogic === 'at' && priceDiff <= threshold;
        }
        
        case 'under-200ma': {
          // Price is below 200-day moving average by specific percentage
          if (!stock.currentPrice || !stock.ma200) return false;
          
          // Calculate how far below 200-day MA
          const priceDiff = (stock.ma200 - stock.currentPrice) / stock.ma200;
          
          // For "below" logic, trigger if price is below MA by at least threshold
          return rule.evaluationLogic === 'below' && priceDiff >= Math.abs(threshold);
        }
        
        default:
          return false;
      }
    }
    
    case 'rsi_data': {
      // Rules using RSI data
      switch (rule.ruleId) {
        case 'rsi-low': {
          // RSI below threshold (oversold)
          if (!stock.rsi14) return false;
          
          // For "below" logic, trigger if RSI is below threshold
          return rule.evaluationLogic === 'below' && stock.rsi14 <= threshold;
        }
        
        case 'rsi-high': {
          // RSI above threshold (overbought)
          if (!stock.rsi14) return false;
          
          // For "above" logic, trigger if RSI is above threshold
          return rule.evaluationLogic === 'above' && stock.rsi14 >= threshold;
        }
        
        default:
          return false;
      }
    }
    
    case 'moving_average_data': {
      // Rules using moving average data
      switch (rule.ruleId) {
        case 'ma50-above-ma200': {
          // 50-day MA is above 200-day MA (golden cross)
          if (!stock.ma50 || !stock.ma200) return false;
          
          // For "above" logic, trigger if 50-day MA is above 200-day MA
          return rule.evaluationLogic === 'above' && stock.ma50 > stock.ma200;
        }
        
        case 'ma50-below-ma200': {
          // 50-day MA is below 200-day MA (death cross)
          if (!stock.ma50 || !stock.ma200) return false;
          
          // For "below" logic, trigger if 50-day MA is below 200-day MA
          return rule.evaluationLogic === 'below' && stock.ma50 < stock.ma200;
        }
        
        case 'price-above-ma50': {
          // Price is above 50-day moving average
          if (!stock.currentPrice || !stock.ma50) return false;
          
          // Calculate how far above 50-day MA
          const priceDiff = (stock.currentPrice - stock.ma50) / stock.ma50;
          
          // For "above" logic, trigger if price is above MA by at least threshold
          return rule.evaluationLogic === 'above' && priceDiff >= threshold;
        }
        
        case 'price-below-ma50': {
          // Price is below 50-day moving average
          if (!stock.currentPrice || !stock.ma50) return false;
          
          // Calculate how far below 50-day MA
          const priceDiff = (stock.ma50 - stock.currentPrice) / stock.ma50;
          
          // For "below" logic, trigger if price is below MA by at least threshold
          return rule.evaluationLogic === 'below' && priceDiff >= threshold;
        }
        
        default:
          return false;
      }
    }
    
    case 'macd_data': {
      // Rules using MACD data
      switch (rule.ruleId) {
        case 'macd-below': {
          // MACD positive crossover (MACD line crosses above signal line)
          if (!stock.macdLine || !stock.macdSignal) return false;
          
          // For "positive" logic, trigger if MACD line is above signal line
          return rule.evaluationLogic === 'positive' && stock.macdLine > stock.macdSignal;
        }
        
        case 'macd-above': {
          // MACD negative crossover (MACD line crosses below signal line)
          if (!stock.macdLine || !stock.macdSignal) return false;
          
          // For "negative" logic, trigger if MACD line is below signal line
          return rule.evaluationLogic === 'negative' && stock.macdLine < stock.macdSignal;
        }
        
        default:
          return false;
      }
    }
    
    case 'portfolio': {
      // Rules using portfolio metrics
      switch (rule.ruleId) {
        case 'max-weight':
        case 'max-weight-intl': {
          // Position weight exceeds threshold
          if (!stock.percentOfPortfolio) return false;
          
          // For "above" logic, trigger if position weight is above threshold
          return rule.evaluationLogic === 'above' && stock.percentOfPortfolio >= threshold;
        }
        
        case 'active-risk': {
          // Active risk isn't available in current data, would need more implementation
          return false;
        }
        
        default:
          return false;
      }
    }
    
    // Other data sources would need additional implementation
    default:
      return false;
  }
}

/**
 * Generate a human-readable message for a triggered rule
 */
function generateAlertMessage(rule: MatrixRule, stock: StockData): string {
  switch (rule.ruleId) {
    case 'price-52wk':
      return `Price is ${Math.round(((stock.fiftyTwoWeekHigh! - stock.currentPrice!) / stock.fiftyTwoWeekHigh!) * 100)}% below 52-week high`;
      
    case 'rsi-low':
      return `RSI(14) is ${Math.round(stock.rsi14!)} - below oversold threshold`;
      
    case 'rsi-high':
      return `RSI(14) is ${Math.round(stock.rsi14!)} - above overbought threshold`;
      
    case 'macd-below':
      return `MACD positive crossover detected`;
      
    case 'macd-above':
      return `MACD negative crossover detected`;
      
    case 'golden-cross-pos':
    case 'ma50-above-ma200':
      return `Golden Cross detected (50MA > 200MA)`;
      
    case 'golden-cross-neg':
    case 'ma50-below-ma200':
      return `Death Cross detected (50MA < 200MA)`;
      
    case 'price-90day':
      return `Price increased ${Math.round(stock.priceChange90d! * 100)}% over 90 days`;
      
    case 'max-weight':
    case 'max-weight-intl':
      return `Position weight is ${Math.round(stock.percentOfPortfolio! * 100)}% of portfolio`;
      
    case 'at-200ma':
      return `Price is at 200-day moving average (Â±${Math.round(Math.abs((stock.currentPrice! - stock.ma200!) / stock.ma200!) * 100)}%)`;
      
    case 'under-200ma':
    case 'price-below-ma200':
      return `Price is ${Math.round((stock.ma200! - stock.currentPrice!) / stock.ma200! * 100)}% below 200-day MA`;
      
    case 'price-above-ma50':
      return `Price is ${Math.round((stock.currentPrice! - stock.ma50!) / stock.ma50! * 100)}% above 50-day MA`;
      
    case 'price-below-ma50':
      return `Price is ${Math.round((stock.ma50! - stock.currentPrice!) / stock.ma50! * 100)}% below 50-day MA`;
      
    case 'price-above-ma200':
      return `Price is ${Math.round((stock.currentPrice! - stock.ma200!) / stock.ma200! * 100)}% above 200-day MA`;
      
    default:
      return `${rule.ruleName} triggered`;
  }
}

/**
 * Generate alert details with specific metrics
 */
function generateAlertDetails(rule: MatrixRule, stock: StockData): string {
  let details = '';
  
  switch (rule.ruleId) {
    case 'price-52wk':
      details = `Current: $${stock.currentPrice!.toFixed(2)}, 52wk High: $${stock.fiftyTwoWeekHigh!.toFixed(2)} (-${((stock.fiftyTwoWeekHigh! - stock.currentPrice!) / stock.fiftyTwoWeekHigh! * 100).toFixed(1)}%)`;
      break;
      
    case 'rsi-low':
    case 'rsi-high':
      details = `RSI(14): ${stock.rsi14!.toFixed(1)}, Threshold: ${parseThreshold(rule.thresholds[normalizeStockType(stock.stockType)][stock.rating as Rating]!)}`;
      break;
      
    case 'macd-below':
    case 'macd-above':
      details = `MACD: ${stock.macdLine!.toFixed(3)}, Signal: ${stock.macdSignal!.toFixed(3)}, Histogram: ${stock.macdHistogram!.toFixed(3)}`;
      break;
      
    case 'golden-cross-pos':
    case 'golden-cross-neg':
    case 'ma50-above-ma200':
    case 'ma50-below-ma200':
      details = `50-day MA: ${stock.ma50!.toFixed(2)}, 200-day MA: ${stock.ma200!.toFixed(2)}`;
      break;
      
    case 'price-90day':
      const threshold90d = rule.thresholds[normalizeStockType(stock.stockType)]?.[stock.rating as Rating];
      const parsed90d = threshold90d ? parseThreshold(threshold90d) : null;
      details = `90-day price change: ${(stock.priceChange90d! * 100).toFixed(1)}%, Threshold: ${parsed90d !== null ? (parsed90d * 100).toFixed(1) : 'N/A'}%`;
      break;
      
    case 'max-weight':
    case 'max-weight-intl':
      const thresholdWeight = rule.thresholds[normalizeStockType(stock.stockType)]?.[stock.rating as Rating];
      const parsedWeight = thresholdWeight ? parseThreshold(thresholdWeight) : null;
      details = `Current weight: ${(stock.percentOfPortfolio! * 100).toFixed(1)}%, Threshold: ${parsedWeight !== null ? (parsedWeight * 100).toFixed(1) : 'N/A'}%`;
      break;
      
    case 'at-200ma':
      details = `Current: $${stock.currentPrice!.toFixed(2)}, 200-day MA: $${stock.ma200!.toFixed(2)}, Diff: ${(Math.abs(stock.currentPrice! - stock.ma200!) / stock.ma200! * 100).toFixed(1)}%`;
      break;
      
    case 'under-200ma':
    case 'price-below-ma200':
      details = `Current: $${stock.currentPrice!.toFixed(2)}, 200-day MA: $${stock.ma200!.toFixed(2)}, Below by: ${((stock.ma200! - stock.currentPrice!) / stock.ma200! * 100).toFixed(1)}%`;
      break;
      
    case 'price-above-ma50':
      details = `Current: $${stock.currentPrice!.toFixed(2)}, 50-day MA: $${stock.ma50!.toFixed(2)}, Above by: ${((stock.currentPrice! - stock.ma50!) / stock.ma50! * 100).toFixed(1)}%`;
      break;
      
    case 'price-below-ma50':
      details = `Current: $${stock.currentPrice!.toFixed(2)}, 50-day MA: $${stock.ma50!.toFixed(2)}, Below by: ${((stock.ma50! - stock.currentPrice!) / stock.ma50! * 100).toFixed(1)}%`;
      break;
      
    case 'price-above-ma200':
      details = `Current: $${stock.currentPrice!.toFixed(2)}, 200-day MA: $${stock.ma200!.toFixed(2)}, Above by: ${((stock.currentPrice! - stock.ma200!) / stock.ma200! * 100).toFixed(1)}%`;
      break;
      
    default:
      details = `${stock.symbol} (${stock.stockType} - Rating ${stock.rating})`;
  }
  
  return details;
}

/**
 * Determine alert severity based on rule type and stock details
 */
function determineAlertSeverity(rule: MatrixRule, stock: StockData): 'critical' | 'warning' | 'info' {
  // Position decrease rules are more urgent than increase rules
  if (rule.actionType === 'Decrease') {
    // High-rated stocks (1-2) with decrease signals are critical
    if (['1', '2'].includes(stock.rating)) {
      return 'critical';
    }
    return 'warning';
  }
  
  // Rating decrease rules are warnings
  if (rule.actionType === 'Rating' && rule.ratingAction === 'Decrease') {
    return 'warning';
  }
  
  // All other rules are info level
  return 'info';
}

/**
 * Get all matrix rules from the API
 */
async function getAllMatrixRules(): Promise<MatrixRule[]> {
  try {
    // For now, we'll use the hardcoded matrix rules since the API is using a mock implementation
    const increaseRules: MatrixRule[] = [
      {
        id: 1,
        ruleId: 'price-52wk',
        ruleName: 'Price % vs 52-wk High',
        description: 'Triggers when current price is below 52-week high by specified percentage',
        actionType: 'Increase',
        thresholds: MATRIX_THRESHOLDS['price-52wk'],
        evaluationMethod: 'percent',
        evaluationLogic: 'below',
        dataSource: 'historical_prices',
        orderNumber: 1
      },
      {
        id: 2,
        ruleId: 'rsi-low',
        ruleName: 'RSI Below Threshold',
        description: 'Triggers when 14-day RSI falls below specified value indicating oversold condition',
        actionType: 'Increase',
        thresholds: MATRIX_THRESHOLDS['rsi-low'],
        evaluationMethod: 'value',
        evaluationLogic: 'below',
        dataSource: 'rsi_data',
        orderNumber: 2
      },
      {
        id: 3,
        ruleId: 'macd-below',
        ruleName: 'MACD Positive Crossover',
        description: 'Triggers when MACD line crosses above signal line indicating positive momentum shift',
        actionType: 'Increase',
        thresholds: MATRIX_THRESHOLDS['macd-below'],
        evaluationMethod: 'delta',
        evaluationLogic: 'positive',
        dataSource: 'macd_data',
        orderNumber: 3
      },
      {
        id: 4,
        ruleId: 'golden-cross-pos',
        ruleName: 'Golden Cross',
        description: 'Triggers when 50-day MA crosses above 200-day MA indicating bullish trend',
        actionType: 'Increase',
        thresholds: MATRIX_THRESHOLDS['golden-cross-pos'],
        evaluationMethod: 'delta',
        evaluationLogic: 'positive',
        dataSource: 'historical_prices',
        orderNumber: 4
      },
      {
        id: 5,
        ruleId: 'sector-perf-neg',
        ruleName: 'Sector Underperformance',
        description: 'Triggers when sector underperforms broader market by specified percentage',
        actionType: 'Increase',
        thresholds: MATRIX_THRESHOLDS['sector-perf-neg'],
        evaluationMethod: 'percent',
        evaluationLogic: 'below',
        dataSource: 'market_indices',
        orderNumber: 5
      },
      {
        id: 6,
        ruleId: 'at-200ma',
        ruleName: 'At 200-day Moving Average',
        description: 'Triggers when price is near 200-day moving average indicating potential support',
        actionType: 'Increase',
        thresholds: MATRIX_THRESHOLDS['at-200ma'],
        evaluationMethod: 'percent',
        evaluationLogic: 'at',
        dataSource: 'historical_prices',
        orderNumber: 6
      }
    ];

    const decreaseRules: MatrixRule[] = [
      {
        id: 7,
        ruleId: 'price-90day',
        ruleName: '90-day Price Increase',
        description: 'Triggers when price increases by specified percentage over 90 days',
        actionType: 'Decrease',
        thresholds: MATRIX_THRESHOLDS['price-90day'],
        evaluationMethod: 'percent',
        evaluationLogic: 'above',
        dataSource: 'historical_prices',
        orderNumber: 1
      },
      {
        id: 8,
        ruleId: 'max-weight',
        ruleName: 'Maximum Position Weight',
        description: 'Triggers when position weight exceeds specified percentage of portfolio',
        actionType: 'Decrease',
        thresholds: MATRIX_THRESHOLDS['max-weight'],
        evaluationMethod: 'percent',
        evaluationLogic: 'above',
        dataSource: 'portfolio',
        orderNumber: 2
      },
      {
        id: 11,
        ruleId: 'rsi-high',
        ruleName: 'RSI Above Threshold',
        description: 'Triggers when 14-day RSI rises above specified value indicating overbought condition',
        actionType: 'Decrease',
        thresholds: MATRIX_THRESHOLDS['rsi-high'],
        evaluationMethod: 'value',
        evaluationLogic: 'above',
        dataSource: 'rsi_data',
        orderNumber: 5
      },
      {
        id: 12,
        ruleId: 'macd-above',
        ruleName: 'MACD Negative Crossover',
        description: 'Triggers when MACD line crosses below signal line indicating negative momentum shift',
        actionType: 'Decrease',
        thresholds: MATRIX_THRESHOLDS['macd-above'],
        evaluationMethod: 'delta',
        evaluationLogic: 'negative',
        dataSource: 'macd_data',
        orderNumber: 6
      },
      {
        id: 13,
        ruleId: 'golden-cross-neg',
        ruleName: 'Death Cross',
        description: 'Triggers when 50-day MA crosses below 200-day MA indicating bearish trend',
        actionType: 'Decrease',
        thresholds: MATRIX_THRESHOLDS['golden-cross-neg'],
        evaluationMethod: 'delta',
        evaluationLogic: 'negative',
        dataSource: 'historical_prices',
        orderNumber: 7
      },
      {
        id: 15,
        ruleId: 'under-200ma',
        ruleName: 'Under 200-day Moving Average',
        description: 'Triggers when price falls below 200-day moving average by specified percentage',
        actionType: 'Decrease',
        thresholds: MATRIX_THRESHOLDS['under-200ma'],
        evaluationMethod: 'percent',
        evaluationLogic: 'below',
        dataSource: 'historical_prices',
        orderNumber: 9
      }
    ];

    // Combine all rule types
    return [...increaseRules, ...decreaseRules];
  } catch (error) {
    console.error('Error fetching matrix rules:', error);
    return [];
  }
}

/**
 * Run the matrix engine to evaluate all rules against all stocks
 */
export async function runMatrixEngine(region: Region): Promise<Alert[]> {
  try {
    console.log(`Running Matrix Engine for ${region} region...`);
    
    // Get all rules
    const rules = await getAllMatrixRules();
    if (!rules.length) {
      console.error('No matrix rules found');
      return [];
    }
    
    // Get stock data for evaluation
    const stocks = await getStockData(region);
    if (!stocks.length) {
      console.error(`No stocks found for region: ${region}`);
      return [];
    }
    
    console.log(`Evaluating ${rules.length} rules against ${stocks.length} stocks in ${region} region`);
    
    // Evaluate each stock against each rule
    const alerts: Alert[] = [];
    
    for (const stock of stocks) {
      for (const rule of rules) {
        // Skip if rule not applicable for this region
        if ((rule.ruleId === 'max-weight-intl' && region !== 'INTL') ||
            (rule.ruleId === 'max-weight' && region === 'INTL')) {
          continue;
        }
        
        // Check if rule is triggered
        const isTriggered = evaluateRule(rule, stock);
        
        if (isTriggered) {
          // Generate alert
          const alert: Alert = {
            symbol: stock.symbol,
            message: generateAlertMessage(rule, stock),
            details: generateAlertDetails(rule, stock),
            severity: determineAlertSeverity(rule, stock),
            ruleType: rule.ruleId,
            region
          };
          
          alerts.push(alert);
          console.log(`Alert triggered for ${stock.symbol}: ${rule.ruleName}`);
        }
      }
    }
    
    console.log(`Matrix Engine generated ${alerts.length} alerts for ${region} region`);
    return alerts;
  } catch (error) {
    console.error(`Error running Matrix Engine for ${region}:`, error);
    return [];
  }
}

/**
 * Save alerts to the database
 */
export async function saveAlerts(generatedAlerts: Alert[]): Promise<boolean> {
  try {
    if (!generatedAlerts.length) {
      console.log('No alerts to save');
      return true;
    }
    
    console.log(`Saving ${generatedAlerts.length} alerts to database`);
    
    // Clear existing active alerts first (optional, depends on requirements)
    await db.delete(alerts).where(eq(alerts.isActive, true));
    
    // Insert new alerts
    for (const alert of generatedAlerts) {
      await db.insert(alerts).values({
        symbol: alert.symbol,
        message: alert.message,
        details: alert.details,
        severity: alert.severity,
        ruleType: alert.ruleType,
        isActive: true
      });
    }
    
    return true;
  } catch (error) {
    console.error('Error saving alerts to database:', error);
    return false;
  }
}

/**
 * Run the matrix engine for all regions
 */
export async function runMatrixEngineForAllRegions(): Promise<Alert[]> {
  try {
    console.log('Running Matrix Engine for all regions...');
    
    const allAlerts: Alert[] = [];
    
    for (const region of REGIONS) {
      const regionAlerts = await runMatrixEngine(region);
      allAlerts.push(...regionAlerts);
    }
    
    console.log(`Matrix Engine completed with ${allAlerts.length} total alerts`);
    
    // Save all alerts to database
    await saveAlerts(allAlerts);
    
    return allAlerts;
  } catch (error) {
    console.error('Error running Matrix Engine for all regions:', error);
    return [];
  }
}

/**
 * Get currently triggered alerts (active alerts from database)
 */
export async function getActiveAlerts(): Promise<Alert[]> {
  try {
    // Get active alerts from database
    const dbAlerts = await db.select().from(alerts).where(eq(alerts.isActive, true));
    
    // Map database alerts to our Alert interface
    return dbAlerts.map(dbAlert => ({
      symbol: dbAlert.symbol,
      message: dbAlert.message,
      details: dbAlert.details || '',
      severity: dbAlert.severity as 'critical' | 'warning' | 'info',
      ruleType: dbAlert.ruleType,
      region: '' // Region may not be stored in alerts table
    }));
  } catch (error) {
    console.error('Error getting active alerts:', error);
    
    // If we can't access the database, return mock alerts for demonstration
    return [
      {
        symbol: 'MSFT',
        message: 'RSI below threshold',
        details: 'Current RSI(14): 29.8, Threshold: 30',
        severity: 'info',
        ruleType: 'rsi-low',
        region: 'USD'
      },
      {
        symbol: 'AAPL',
        message: 'Price > 20% from 52-week high',
        details: 'Current: $208.65, 52wk high: $274.21 (-23.9%)',
        severity: 'warning',
        ruleType: 'price-52wk',
        region: 'USD'
      },
      {
        symbol: 'META',
        message: 'MACD positive crossover',
        details: 'Signal line crossed by MACD line',
        severity: 'info',
        ruleType: 'macd-below',
        region: 'USD'
      }
    ];
  }
}